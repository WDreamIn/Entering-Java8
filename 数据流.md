# 数据流如何工作

数据流表示元素的序列，并支持不同种类的操作来执行元素上的计算：

```java
List<String> myList = 
    Arrays.asList("a1","a2","b1","c2","c1");

myList
	.stream()
    .filter(s -> s.startsWith("c"))
    .map(String::toUpperCase)
    .sorted()
    .forEach(System.out::println);


```

数据流操作要么是衔接操作，要么是终止操作。衔接操作返回数据流，所以我们可以把多个衔接操作不使用分号来链接到一起。终止操作无返回值，或者返回一个不是流的结果。在上面的例子中，filter,map 和 sorted 都是衔接操作，而 forEach 是终止操作。

多数数据流操作都接受一些lambda 表达式参数，函数式接口用来指定操作的具体行为。这些操作的大多数必须是**无干扰**而且是无状态的。

当一个函数不修改数据流的底层数据源，他就是**无干扰**的。例如，在上面的例子中，没有任何lambad 表达式通过添加或删除集合元素修改 myList。

当一个函数的操作的执行是确定的，他就是**无状体**的。例如，在上面的例子中，没有任何lambad 表达式依赖于外部作用域中任何在操作过程中可变的变量或状态。

# 数据流的不同类型

数据流可以从多种数据源创建，尤其是集合。List 和 Set 支持新方法 stream（）和 parallelStream（），来创建串行流或并行流。并行流能够在多个线程在多个线程上执行操作，他们会在之后讲到。现在来看串行流：

```java
Arrays.asList("a1","a2","a3")
    .stream()
    .findFirst()
    .ifPresent(System.out::println); // a1
```

在对象列表上调用 stream（）方法会返回一个通用的对象流。但是我们不需要创建一个集合来创建数据流，就像下面那样：

```java
Stream.of("a1","a2","a3")
    .findFirst()
    .ifPresent(System.out::println); //a1
```

只要使用 Stream.of ( ) ,就可以从一些列对象中创建数据流。

除了普通的对象数据流，Java8 还自带了特殊种类的流，用于处理基本数据类型 int、long、 和double。他们是IntStream , LongStream 和 DoubleStream 。

IntStream可以使用IntStream.range( ) 替换通常的for 循环：

```java
IntStream.range(1,4)
    .forEach(System.out::println);
```

所有这些基本数据流都想通常的对象数据流一样，但有些不同。基本的数据流使用特殊的lambda 表达式，例如，IntFunction 而不是Function，IntPredicate 而不是Predicate。而且基本数据流支持额外的聚合终止操作sum（）和 average（）：

```java
Arrays.stream(new int[]{1,2,3})
    .map(n -> 2*n + 1)
    .average()
    .ifPresent(System.out::println); // 5.0
```

有时需要将通常的对象数据流转换为基本数据流，或者相反。出于这种目的，对象数据流支持特殊的映射操作 mapToInt（）、mapToLong 和 mapToDouble（）：

```java
Stream.of("a1","a2","a3")
    .map(s -> s.substring(1))
    .mapToInt(Integer::parseInt)
    .max()
    .ifPresent(System.out::println); // 3
```

基本数据流可以通过 mapToObj（）转换为对象数据流：

```java
IntStream.range(1,4)
    .mapToObj(i -> "a" +i)
    .forEach(System.out::println);
// a1
// a2
// a3
```

下面是组合实例：浮点数据流首先映射为整数数据流，之后映射为字符串的对象数据流：

```java
Stream.of(1.0,2.0,3.0)
    .mapToInt(Double::intValue)
    .mapToObj(i -> "a" + i)
    .forEach(System.out::println);
// a1
// a2
// a3
```

所有这些基本数据流都像通常的对象数据流一样，但有一些不同。基本的数据流使用特殊的lambada表达式，例如，IntFunction 而不是 Function ，IntPredicate 而不是Predicate。而且基本数据流支持额外的聚合终止操作 sum （）和 average （）：

```java
Arrays.stream(new int[] {1,2,3})
    .map(n -> 2*n + 1)
    .average()
    .ifPresent(System.out::println); // 5.0
```

有时需要将通常的对象数据流转为基本数据流，或者相反。出于这种目的，对象数据流支持特殊的映射操作 mapToInt（），mapToLong（）和mapToDouble（）：

```java
Stream.of("a1","a2","a3")
    .map(s -> s.substring(1))
    .maoToInt(Integer::parseInt)
    .max()
    .ifPresent(System.out::println); // 3
```

基本数据流可以通过 mapToObj（）转换为对象数据流：

```java
IntStream.range(1,4)
    .mapToObj(i -> "a" + i)
    .forEach(System.out::println);
```

衔接是组合实例：浮点数据流首先映射为整数数据流，之后映射为字符串的对象数据流：

```java
Stream.of(1.0,2.0,3.0)
    .mapToInt(Double::intValue)
    .mapToObj(i -> "a" + 1)
    .forEach(System.out::println);

// a1
// a2
// a3
```

## 处理顺序

既然我们已经了解了如何创建并使用不同种类的数据流，让我们深入了解数据流操作在背后如何执行吧。衔接操作的一个重要特性就是延迟性。观察下面没有终止操作的例子：

```java
Stream.of("d2","a2","b1","b3","c")
    .filter(s -> {
        System.out.println("filter:" + s);
        return true;
    })
```

执行这段代码时，不向控制台打印任何东西。这是因为衔接操作只在终止操作调用时被执行。

让我们通过添加终止操作 forEach 来扩展这个例子：

```java
Stream.of("d2","a2","b1","b3","c")
    .filter(s -> {
        System.out.println("filter:" + s);
        return true;
    })
    .forEach(s -> System.out.println("forEach" + s));
```

输出结果：

```java
filter:  d2
forEach: d2
filter:  a2
forEach: a2
filter:  b1
forEach: b1
filter:  b3
forEach: b3
filter:  c
forEach: c
```

原始的方法会在数据流的所有元素上，一个接一个地水平执行所有操作。但是每个元素在调用链上垂直移动。第一个字符串 “d2” 首先经过filter 然后是 forEach ，执行完后才开始处理第二个字符串 “a2” 。

这种行为可以减少每个元素上执行的实际操作数量，就像我们在下个例子中看到的样：

```java
Stream.of("d2","a2","b1","b3","c")
    .map(s -> {
        System.out.println("map" + s);
        return s.toUpperCase()
    })
    .anyMatch(s -> {
       System.out.println("anyMatch: " + s);
       return s.startsWith("A");
    });

// map:   d2
// anyMatch: D2
// map:  a2
// anyMatch: A2
```

只要提供的数据元素满足了谓词，anyMatch 操作就会返回 true 。对于第二个传递 “A2” 的元素，它的结果为真。由于数据流的链式调用是垂直执行的，map这里只需要执行两次。所以map 会执行尽可能少的次数，而不是把所有元素都映射一遍。

## 为什么顺序如此重要

```java
Stream.of("d2","a2","b1","b3","c")
    .map(s -> {
        System.out.println("map: " + s);
        return s.toUpperCase;
    })
    .filter(s -> {
        System.out.println("filter: " + s);
        return s.startsWith("A");
    })
    .forEach(s -> System.out.println("forEach:" + s));

// map:  d2
// filter: D2
// map:   a2
// filter: A2
// forEach: A2
// map: b1
// filter:  B1
// map:     b3
// filter:  B3
// map:     c
// filter:  C
```



map 和 filter 会对底层集合的每个字符串调用五次，而 forEach 只会调用一次。

如果我们调整操作顺序，将 filter 移动到调用链的顶端，就可以极大减少操作的执行次数：

```java
Stream.of("d2","a2","b1","b3","c")
    .filter(s -> {
        System.out.println("filter: " + s);
        return s.startsWith("a");
    })
    .map(s -> {
        System.out.println("map:" + s);
        return s.toUpperCase();
    })
    .forEach(s -> System.out.println("forEach:" +s));

// filter:  d2
// filter:  a2
// map:     a2
// forEach: A2
// filter:  b1
// filter:  b3
// filter:  c
```

现在，map只会调用一次，所以操作流水线对于更多的输入元素会执行的更快。在整合复杂的方法链时，要记住这一点。

让我们通过添加额外的方法 sorted 来扩展上面的例子：

```java
Stream.of("d2","a2","b1","b3","c")
    .sorted((s1,s2) -> {
        System.out.println("sort: %s; %s \n",s1,s2);
        return s1.compareTo(s2);
    })
    .filter(s -> {
        System.out.println("filter: " + s);
        return s.starsWith("a");
    })
    .map(s -> {
        System.out.println("map:" + s);
        return s.toUpperCase();
    })
    .forEach(s -> System.out.println("forEach: " + s));
```

首先，排序操作在整个输入集合上执行。也就是说，`sorted`以水平方式执行。所以这里`sorted`对输入集合中每个元素的多种组合调用了八次。

我们同样可以通过重排调用链来优化性能：

```java
Stream.of("d2", "a2", "b1", "b3", "c")
    .filter(s -> {
        System.out.println("filter: " + s);
        return s.startsWith("a");
    })
    .sorted((s1, s2) -> {
        System.out.printf("sort: %s; %s\n", s1, s2);
        return s1.compareTo(s2);
    })
    .map(s -> {
        System.out.println("map: " + s);
        return s.toUpperCase();
    })
    .forEach(s -> System.out.println("forEach: " + s));

// filter:  d2
// filter:  a2
// filter:  b1
// filter:  b3
// filter:  c
// map:     a2
// forEach: A2
```

这个例子中`sorted`永远不会调用，因为`filter`把输入集合减少至只有一个元素。所以对于更大的输入集合会极大提升性能。

## 服用数据流

java 8 的数据流不能被复用。一旦你调用了任何终止操作，数据流就关闭了：

```java
Stream<String> stream = 
    Stream.of("d2","a2","b1","b3","c")
    .filter(s -> s.startsWith("a"));

stream.anyMatch(s -> true); //ok
stream.noneMatch(s -> true);  // exception
```

在相同数据流上，在 anyMatch 之后调用noneMatch 会产生下面的异常：

```java
java.lang.IllegalStateException: stream has already been operated upon or closed
    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)
    at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459)
    at com.winterbe.java8.Streams5.test7(Streams5.java:38)
    at com.winterbe.java8.Streams5.main(Streams5.java:28)

```

要克服这个限制，我们需要为每个想要执行的终止操作创建新的数据流调用链。例如，我们创建一个数据流供应器，来创建新的数据流，并且设置好所有衔接操作：

```java
Supplier<Stream<String>> streamSupplier = 
    () -> Stream.of("d2","a2","b1","b3","c")
    	.filter(s -> s.startsWith("a"));
streamSupplier.get().anyMatch(s -> true);  // ok
streamSupplier.get().noneMatch(s -> true); // ok

```

每次对 get（）的调用都构造了一个新的数据流，我们将其保存起来调用终止操作。

## 高级操作

数据流执行大量的不同操作。这里给出一些更复杂的操作：collect，flatMap 和 reduce。

Person列表：

```java
class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return name;
    }
}

List<Person> persons =
    Arrays.asList(
        new Person("Max", 18),
        new Person("Peter", 23),
        new Person("Pamela", 23),
        new Person("David", 12));
```

### collect

Collect 是非常有用的终止操作，将流中的元素存放在不类型的结果中，例如：List，Set 或者Map。collect 接受收集器（Collector），它由四个不同的操作组成：供应器（supplier）、累加器（accumulator）、组合器（combiner）和终止器（finisher）。这在开始听起来十分复杂，但是Java8通过内置的Collectors 类支持多种内置的收集器。所以对于大部分常见操作，你并不需要自己实现收集器。

```java
List<Person> filtered = 
    persons
    	.stream()
    	.filter(p -> p.name.startsWith("p"))
    	.collect(Collectors.toList());

System.out.println(filtered);  //  [Perter, Pamela]
```

只从流的元素中构造了一个列表。如果需要以Set来替代List，只需要使用Collectors.toSet就好了。

下面的例子按照年龄对所有人进行分组：

```java
Map<Integer,List<Person>> personsByAge = persons
	.stream()
    .collect(Collectors.groupingBy(p -> p.age));

personsByAge
	.forEach(age,p) -> System.out.format("age %s: %s\n",age,p);

// age 18: [Max]
// age 23: [Peter, Pamela]
// age 12: [David]
```

收集器十分灵活。也可以在流的元素上执行聚合，例如，计算所有人的平均年龄：

```java
Double averageAge = persons
	.stream()
    .collect(Collectors.averagingInt(p -> p.age));

System.out.println(averageAge);  //19.0

```

如果你对更多统计学方法感兴趣，概要收集器返回一个特殊的内置概要统计对象，所以我们可以简单计算最小年龄、最大年龄、算术平均年龄、总和和数量。

```java
IntSummaryStatistics ageSummary =
    persons
        .stream()
        .collect(Collectors.summarizingInt(p -> p.age));

System.out.println(ageSummary);
// IntSummaryStatistics{count=4, sum=76, min=12, average=19.000000, max=23}
```

下面的例子将所有人连接为一个字符串：

```java
String phrase = persons
	.stream()
    .filter(p -> p.age >= 18)
    .map(p -> p.name)
    .collect(Collectors.joining("and","In China","are of legal age"));

System.out.println(phrase);

// In China Max and Peter and Pamela are of legal age
```

